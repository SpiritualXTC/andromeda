#include <andromeda/Renderer/render_cache.h>

#include "renderable_group.h"

#include <cassert>


#include <andromeda/Game/game_object.h>
#include <andromeda/Game/transform_component.h>

#include <andromeda/Math/region.h>

#include <andromeda/Renderer/camera.h>
#include <andromeda/Renderer/scene_graph.h>
#include <andromeda/Renderer/transform.h>
#include <andromeda/Renderer/view.h>


using namespace andromeda;

#if 0
/*

*/
SceneGraphCache::SceneGraphCache(View * view, Camera * camera)
	: _view(view)
	, _camera(camera)
{
	assert(_view);

}


/*

*/
SceneGraphCache::~SceneGraphCache()
{

}






/*
	Is this object in the scene
*/
Boolean SceneGraphCache::hasObject(std::shared_ptr<GameObject> object)
{
	// Validate Object
	assert(object);

	return exists(object->getId());
}





/*
	Adds a game object
*/
Boolean SceneGraphCache::addGameObject(std::shared_ptr<GameObject> object)
{
	// Validate Object
	assert(object);

	// There may be a situation where an object should be rejected by a view for adding
	// An Example would be:
	/*
	View Main:
	- The Main Display

	Object A:
	- Is a display terminal for a CCTV camera. Camera A
	- It therefore has a view. View A
	- Camera A is directly facing Object A

	When Object A becomes active to View Main:
	- A Dynamic View is added to the view list
	- The Dynamic View will process the scene from it's POV
	- It will "see" Object A and activate Object A for View A


	Aspects of this scenario need to be prevented, while aspects need to be allowed:
	- A Dynamic View will not be able to be add to the view list multiple times [Handled by the renderer or view list]
	- It will also need some "smart" management. Such as a reference counter
	- The Dynamic View should be able to render itself. [Backbuffer swapping]
	*/

	// Execute a bunch of callbacks :: This may work better straight on the game object... but needs some "smart" mechanisms


	Boolean b = insert(object->getId());
	if (b)
	{
	//	object->onViewActivate(_view);

		_objects.insert_or_assign(object->getId(), object);
	}

	return b;
}


/*
	Removes a game object
*/
Boolean SceneGraphCache::removeGameObject(std::shared_ptr<GameObject> object)
{
	assert(object);

	Boolean b = erase(object->getId());
	if (b)
	{
	//	object->onViewDeactivate(_view);
		_objects.erase(object->getId());
	}
	
	return b;
}



/*

*/
Boolean SceneGraphCache::clearObjects()
{
	/*
		TODO:
		This will need to be tested .... somehow
	*/

	for (const auto & it : _objects)
	{
	//	it.second->onViewDeactivate(_view);
	}

	_objects.clear();
	_table.clear();

	return true;
}






/*
	Does it exist in the Table
*/
Boolean SceneGraphCache::exists(UInt64 id)
{
	auto it = _table.find(id);

	// Was the Key found?
	// Return the Value.
	// This allows keys that exist in the table to set to false, without the need for removal :: however removing is currently still a requirement while using unordered_map
	return it == _table.end() ? false : it->second;
}



/*
	Inserts the ID into the lookup table
*/
Boolean SceneGraphCache::insert(UInt64 id)
{
	auto & it = _table.insert_or_assign(id, true);

	return it.second;
}


/*
	Removes the ID from the lookup table
*/
Boolean SceneGraphCache::erase(UInt64 id)
{
	// Override Flag
	if (exists(id))
		_table[id] = false;

	// Erase from Map
	Size removed = _table.erase(id);

	// Return whether any elements were removed
	return removed > 0;
}











/*

*/
void SceneGraphCache::process(const std::shared_ptr<GameObject> & go)
{
	assert(go);
	assert(_camera);
	




	// Cache Check :: Is it already in the cache
	Boolean cached = exists(go->getId());

	// Visible :: Does the object pass the visibility check
	Boolean visible = true;

//	if (!! _visibility)
//		visible = _visibility->isVisible(go);


	/*
		TODO:
		This needs to be an AABB
		Add functionality to the GameObject to get an AABB ... fast

		The function however needs to be to handle an accumlated AABB such as that generated by a scene heirarchy

		2 AABB will need to be associated for each object.
		 - The Heirarchy AABB.
			This includes all objects that treat this object as a parent in the scene graph
		 - The Object AABB
			The object AABB, this wraps the display dimensions of an object


		Currently is using a primitive sphere for visibility detection
	*/
	// Get Transform Component
	std::shared_ptr<ITransform> transform = go->getComponentPtr<TransformComponent>();

	if (transform)
	{
		const glm::vec3 & position = transform->position();

		visible = _camera->isVisible(position, 0.1f);
	}








	// Object is Visble && It's Cached.				:: Nothing needs to be done
	// Object is NOT Visible && It's NOT Cached		:: Nothing needs to be done
	if (visible == cached)
		return; //return visible | cached;


	if (visible)
	{
		//	log_debugp("SceneGraph: Object '%1%' entered screen space. Adding to cache", p->getName());
		addGameObject(go);
	}
	else
	{
		//	log_debugp("SceneGraph: Object '%1%' exited screen space. Removing from Cache", p->getName());
		removeGameObject(go);
	}


	/* 
		This should really return a Boolean, so the SceneGraph knows whether it needs to continue deeper.
		...
		At least when a heirarchial SceneGraph is in use rather than a linear/hashmap one :D

		return VISIBLE or CACHED;

		This means visible objects will process children, but will also allow invisible 
		objects that are still cached to be processed :: So they can be removed from the cache, alongside any child objects
	*/
	// return visible | cached;

	return;
}





#endif













/*
*
*
*
* NEW CLASS
*
*
*
*/


















/*

*/
RenderCache::RenderCache(Camera * camera)
	: _camera(camera)
{
	

}


/*

*/
RenderCache::~RenderCache()
{

}






/*
	Is this object in the scene
*/
Boolean RenderCache::hasObject(std::shared_ptr<GameObject> object)
{
	// Validate Object
	assert(object);

	return exists(object->getId());
}





/*
	Adds a game object
*/
Boolean RenderCache::addGameObject(std::shared_ptr<GameObject> object)
{
	// Validate Object
	assert(object);

	// There may be a situation where an object should be rejected by a view for adding
	// An Example would be:
	/*
	View Main:
	- The Main Display

	Object A:
	- Is a display terminal for a CCTV camera. Camera A
	- It therefore has a view. View A
	- Camera A is directly facing Object A

	When Object A becomes active to View Main:
	- A Dynamic View is added to the view list
	- The Dynamic View will process the scene from it's POV
	- It will "see" Object A and activate Object A for View A


	Aspects of this scenario need to be prevented, while aspects need to be allowed:
	- A Dynamic View will not be able to be add to the view list multiple times [Handled by the renderer or view list]
	- It will also need some "smart" management. Such as a reference counter
	- The Dynamic View should be able to render itself. [Backbuffer swapping]
	*/

	// Execute a bunch of callbacks :: This may work better straight on the game object... but needs some "smart" mechanisms


	Boolean b = insert(object->getId());
	if (b)
	{
		object->onRenderActivate(this);

		_objects.insert_or_assign(object->getId(), object);
	}

	return b;
}


/*
	Removes a game object
*/
Boolean RenderCache::removeGameObject(std::shared_ptr<GameObject> object)
{
	assert(object);

	Boolean b = erase(object->getId());
	if (b)
	{
		object->onRenderDeactivate(this);
		_objects.erase(object->getId());
	}

	return b;
}



/*

*/
Boolean RenderCache::clearObjects()
{
	/*
	TODO:
	This will need to be tested .... somehow
	*/

	for (const auto & it : _objects)
	{
		it.second->onRenderDeactivate(this);
	}

	_objects.clear();
	_table.clear();

	return true;
}




/*
	Gets the RenderGroup
*/
std::shared_ptr<RenderableGroup> RenderCache::getRenderGroup(const std::string & group)
{
	// Find the Group
	const auto & it = _groups.find(group);

	// Found ??
	if (it != _groups.end())
	{
		// Retrieve
		return it->second;
	}

	// Create and Insert
	std::shared_ptr<RenderableGroup> rg = std::make_shared<RenderableGroup>(group);
	_groups[group] = rg;

	return rg;
}




/*
	Adds a renderable to a group
*/
Boolean RenderCache::addRenderable(IRenderable * renderable, const std::string & group)
{
	// Gets the Group
	std::shared_ptr<RenderableGroup> rg = getRenderGroup(group);

	assert(rg);

	// Add Renderable
	rg->addRenderable(renderable);

	return true;
}

/*
	Removes a renderable from the group
*/
Boolean RenderCache::removeRenderable(IRenderable * renderable, const std::string & group)
{
	// Gets the Group
	std::shared_ptr<RenderableGroup> rg = getRenderGroup(group);

	assert(rg);

	// Remove Renderable
	rg->removeRenderable(renderable);

	return true;
}







/*
	Does it exist in the Table
*/
Boolean RenderCache::exists(UInt64 id)
{
	auto it = _table.find(id);

	// Was the Key found?
	// Return the Value.
	// This allows keys that exist in the table to set to false, without the need for removal :: however removing is currently still a requirement while using unordered_map
	return it == _table.end() ? false : it->second;
}



/*
	Inserts the ID into the lookup table
*/
Boolean RenderCache::insert(UInt64 id)
{
	auto & it = _table.insert_or_assign(id, true);

	return it.second;
}


/*
	Removes the ID from the lookup table
*/
Boolean RenderCache::erase(UInt64 id)
{
	// Override Flag
	if (exists(id))
		_table[id] = false;

	// Erase from Map
	Size removed = _table.erase(id);

	// Return whether any elements were removed
	return removed > 0;
}


/*

*/
void RenderCache::process(const std::shared_ptr<GameObject> & go)
{
	assert(go);
	assert(_camera);





	// Cache Check :: Is it already in the cache
	Boolean cached = exists(go->getId());

	// Visible :: Does the object pass the visibility check
	Boolean visible = true;

	//	if (!! _visibility)
	//		visible = _visibility->isVisible(go);


	/*
	TODO:
	This needs to be an AABB
	Add functionality to the GameObject to get an AABB ... fast

	The function however needs to be to handle an accumlated AABB such as that generated by a scene heirarchy

	2 AABB will need to be associated for each object.
	- The Heirarchy AABB.
	This includes all objects that treat this object as a parent in the scene graph
	- The Object AABB
	The object AABB, this wraps the display dimensions of an object


	Currently is using a primitive sphere for visibility detection
	*/
	// Get Transform Component
	std::shared_ptr<ITransform> transform = go->getComponentPtr<TransformComponent>();

	if (transform)
	{
		const glm::vec3 & position = transform->position();

		visible = _camera->isVisible(position, 0.1f);
	}








	// Object is Visble && It's Cached.				:: Nothing needs to be done
	// Object is NOT Visible && It's NOT Cached		:: Nothing needs to be done
	if (visible == cached)
		return; //return visible | cached;


	if (visible)
	{
		//	log_debugp("SceneGraph: Object '%1%' entered screen space. Adding to cache", p->getName());
		addGameObject(go);
	}
	else
	{
		//	log_debugp("SceneGraph: Object '%1%' exited screen space. Removing from Cache", p->getName());
		removeGameObject(go);
	}


	/*
	This should really return a Boolean, so the SceneGraph knows whether it needs to continue deeper.
	...
	At least when a heirarchial SceneGraph is in use rather than a linear/hashmap one :D

	return VISIBLE or CACHED;

	This means visible objects will process children, but will also allow invisible
	objects that are still cached to be processed :: So they can be removed from the cache, alongside any child objects
	*/
	// return visible | cached;

	return;
}